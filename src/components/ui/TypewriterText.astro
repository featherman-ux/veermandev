
---
export interface Props {
  words: string[];
  className?: string;
  initialText?: string;
  cursorClass?: string;
}

const { words, className = "text-primary", initialText, cursorClass = "terminal-cursor" } = Astro.props;

// Keep the longest word for sizing so the container doesn't jump.
const longestWord = words.reduce((a, b) => (a.length > b.length ? a : b), initialText ?? '');
---

<div class="typewriter-container">
  <div class="typewriter-grid">
    <!-- Sizer and Text are in the same grid cell -->
    <span class:list={['typewriter-sizer', className]} aria-hidden="true">{longestWord}</span>
    <span class="typewriter-wrapper">
      <span 
        class:list={['typewriter-text', className]}
        data-words={JSON.stringify(words)}
        data-cursor-class={cursorClass}
      >
        {initialText || words[0]}
      </span>
    </span>
  </div>
</div>

<style>
  .typewriter-container {
    display: inline-block; /* Ensures it behaves like a text element */
    vertical-align: bottom; /* Aligns with surrounding text */
  }

  .typewriter-grid {
    display: inline-grid; /* Use grid layout */
    grid-template-areas: "stack"; /* Define a single area */
    text-align: center;
    vertical-align: bottom;
  }

  .typewriter-sizer,
  .typewriter-wrapper {
    grid-area: stack; /* Place both elements in the same area */
  }

  .typewriter-sizer {
    visibility: hidden;
    display: inline-block;
    white-space: normal;
    word-break: break-word;
  }

  .typewriter-wrapper {
    display: inline-flex;
    align-items: baseline;
    justify-content: center;
    gap: 0;
    text-align: center;
    flex-wrap: nowrap;
  }

  .typewriter-wrapper {
    display: inline-flex;
    justify-content: center;
    position: relative;
    min-height: calc(1.2em * 2);
  }

  @media (max-width: 640px) {
    .typewriter-wrapper {
      min-height: calc(1.2em * 3);
    }
  }

  .typewriter-text {
    white-space: normal;
    word-break: break-word;
    display: inline-block;
    transition: opacity 0.4s ease, transform 0.4s ease;
    opacity: 1;
    position: relative;
  }

  .typewriter-text.is-fading-out {
    opacity: 0;
    transform: translateY(0.35rem);
  }

  .typewriter-text.is-fading-in {
    opacity: 1;
    transform: translateY(0);
  }

  .typewriter-text::after {
    content: '|';
    display: inline-block;
    margin-left: 0.1rem;
    animation: blink 1s infinite;
    color: inherit;
  }

  @keyframes blink {
    0%, 50% { opacity: 1; }
    51%, 100% { opacity: 0; }
  }
  
  /* Mobile responsive styles can be removed as this approach is fully responsive */
  @media (max-width: 640px) {
    /* This block can now be safely removed */
  }
</style>

<script>
  const setReservedHeights = () => {
    document.querySelectorAll('.typewriter-wrapper').forEach((wrapper) => {
      if (!(wrapper instanceof HTMLElement)) return;
      const typewriterElement = wrapper.querySelector('.typewriter-text');
      if (!(typewriterElement instanceof HTMLElement)) return;

      let words: string[] = [];
      try {
        const parsed = JSON.parse(typewriterElement.dataset.words || '[]');
        if (Array.isArray(parsed)) {
          words = parsed;
        }
      } catch (error) {
        // Ignore parse errors; simply fall back to current text
      }

      const currentText = typewriterElement.textContent?.trim();
      if (currentText && !words.includes(currentText)) {
        words = [currentText, ...words];
      }

      if (words.length === 0) {
        return;
      }

      const measurement = document.createElement('span');
      measurement.className = typewriterElement.className;
      measurement.style.position = 'absolute';
      measurement.style.visibility = 'hidden';
      measurement.style.pointerEvents = 'none';
      measurement.style.whiteSpace = 'normal';
      measurement.style.wordBreak = 'break-word';
      measurement.style.display = 'inline-block';
      measurement.style.top = '0';
      measurement.style.left = '-10000px';

      const container = wrapper.parentElement instanceof HTMLElement ? wrapper.parentElement : wrapper;
      const containerWidth = Math.max(
        container.getBoundingClientRect().width,
        wrapper.getBoundingClientRect().width,
        typewriterElement.getBoundingClientRect().width
      );

      if (containerWidth > 0) {
        measurement.style.width = `${containerWidth}px`;
        measurement.style.maxWidth = `${containerWidth}px`;
      }

      document.body.appendChild(measurement);

      let maxHeight = 0;
      words.forEach((word) => {
        measurement.textContent = word;
        const { height } = measurement.getBoundingClientRect();
        if (height > maxHeight) {
          maxHeight = height;
        }
      });

      measurement.remove();

      const computed = window.getComputedStyle(typewriterElement);
      let lineHeight = parseFloat(computed.lineHeight);
      if (Number.isNaN(lineHeight) || lineHeight === 0) {
        const fontSize = parseFloat(computed.fontSize) || 16;
        lineHeight = fontSize * 1.2;
      }

      const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
      const baseLines = viewportWidth <= 640 ? 3 : 2;
      const baseHeight = lineHeight * baseLines;

      const targetHeight = Math.max(maxHeight, baseHeight);

      if (targetHeight > 0) {
        wrapper.style.minHeight = `${targetHeight}px`;
      }
    });
  };

  const initTypewriters = () => {
    const typewriterElements = document.querySelectorAll('.typewriter-text');

    typewriterElements.forEach((typewriterElement) => {
      if (typewriterElement instanceof HTMLElement) {
        // --- PREVENT RE-INITIALIZATION ---
        if (typewriterElement.dataset.isAnimating === 'true') {
          return;
        }
        typewriterElement.dataset.isAnimating = 'true';
        // --- END PREVENT RE-INITIALIZATION ---

        const words = JSON.parse(typewriterElement.dataset.words || '[]');
        if (!Array.isArray(words) || words.length === 0) {
          return;
        }
        const animationContainer = typewriterElement.closest('.typewriter-heading') || typewriterElement.closest('.typewriter-container');

        const displayDuration = 3000; // time word stays visible
        const transitionDuration = 400; // fade duration

        let currentWordIndex = Math.max(
          words.findIndex((word) => word === typewriterElement.textContent?.trim()),
          0
        );

        typewriterElement.textContent = words[currentWordIndex];
        typewriterElement.classList.add('is-fading-in');

        const cycleWords = () => {
          if (!document.contains(typewriterElement)) {
            return;
          }

          if (animationContainer && animationContainer.classList.contains('is-paused')) {
            window.setTimeout(cycleWords, 200);
            return;
          }

          typewriterElement.classList.add('is-fading-out');

          window.setTimeout(() => {
            if (!document.contains(typewriterElement)) {
              return;
            }

            currentWordIndex = (currentWordIndex + 1) % words.length;
            typewriterElement.textContent = words[currentWordIndex];
            typewriterElement.classList.remove('is-fading-out');
            typewriterElement.classList.add('is-fading-in');

            window.setTimeout(() => {
              typewriterElement.classList.remove('is-fading-in');
              window.setTimeout(cycleWords, displayDuration);
            }, transitionDuration);
          }, transitionDuration);
        };

        window.setTimeout(() => {
          typewriterElement.classList.remove('is-fading-in');
          window.setTimeout(cycleWords, displayDuration);
        }, transitionDuration);
      }
    });
  };

  // Run immediately in case the event has already fired (SSR initial load)
  setReservedHeights();
  initTypewriters();

  // Re-run after Astro navigations
  document.addEventListener('astro:page-load', () => {
    setReservedHeights();
    initTypewriters();
  });
  document.addEventListener('astro:after-swap', () => {
    setReservedHeights();
    initTypewriters();
  });

  window.addEventListener('resize', () => {
    setReservedHeights();
  });

  if ('fonts' in document && typeof (document as any).fonts?.addEventListener === 'function') {
    (document as any).fonts.addEventListener('loadingdone', () => {
      setReservedHeights();
    });
  }
</script>
