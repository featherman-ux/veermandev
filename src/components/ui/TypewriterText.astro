---
export interface Props {
  words: string[];
  className?: string;
  initialText?: string;
  cursorClass?: string;
}

const { words, className = "text-primary", initialText, cursorClass = "terminal-cursor" } = Astro.props;

// Find the longest word to use as a sizer
const longestWord = words.reduce((a, b) => (a.length > b.length ? a : b), '');
---

<div class="typewriter-wrapper">
  <!-- Ghost element to set the container size based on the longest word -->
  <span class="typewriter-sizer" aria-hidden="true">{longestWord}</span>

  <!-- The actual typewriter element, positioned on top of the sizer -->
  <span 
    class={`typewriter-text ${className}`} 
    data-words={JSON.stringify(words)}
    data-cursor-class={cursorClass}
  >
    {initialText || words[0]}
  </span>
</div>

<style>
  .typewriter-wrapper {
    position: relative;
    display: inline-block;
    text-align: center;
    width: auto; /* Size to content (sizer) to prevent odd wraps */
  }

  .typewriter-sizer {
    opacity: 0;
    min-height: 1.2em; /* Ensure it has height even if empty */
    display: block;
    white-space: nowrap;
  }

  .typewriter-text {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: block;
    white-space: nowrap; /* Keep phrase together */
    word-break: keep-all;
    hyphens: none;
  }
  
  .terminal-cursor {
    animation: blink 1s infinite;
    color: currentColor;
  }

  @keyframes blink {
    0%, 50% { opacity: 1; }
    51%, 100% { opacity: 0; }
  }
  
  /* Mobile responsive styles can be removed as this approach is fully responsive */
  @media (max-width: 640px) {
    /* This block can now be safely removed */
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const typewriterElements = document.querySelectorAll('.typewriter-text');
    
    typewriterElements.forEach((typewriterElement) => {
      if (typewriterElement instanceof HTMLElement) {
        const words = JSON.parse(typewriterElement.dataset.words || '[]');
        const cursorClass = typewriterElement.dataset.cursorClass || 'terminal-cursor';
        let currentWordIndex = 0;
        let currentCharIndex = 0;
        let isDeleting = false;
        let isWaiting = false;

        function typeWriter() {
          const currentWord = words[currentWordIndex];
          const shouldDelete = isDeleting;
          const shouldWait = isWaiting;

          if (shouldWait) {
            setTimeout(() => {
              isWaiting = false;
              typeWriter();
            }, 2000);
            return;
          }

          if (shouldDelete) {
            if (currentCharIndex > 0) {
              currentCharIndex--;
              typewriterElement.innerHTML = currentWord.substring(0, currentCharIndex) + `<span class="${cursorClass}">|</span>`;
              setTimeout(typeWriter, 75);
            } else {
              isDeleting = false;
              currentWordIndex = (currentWordIndex + 1) % words.length;
              setTimeout(typeWriter, 200);
            }
          } else {
            if (currentCharIndex < currentWord.length) {
              currentCharIndex++;
              typewriterElement.innerHTML = currentWord.substring(0, currentCharIndex) + `<span class="${cursorClass}">|</span>`;
              setTimeout(typeWriter, 150);
            } else {
              isWaiting = true;
              setTimeout(() => {
                isDeleting = true;
                isWaiting = false;
                typeWriter();
              }, 3000);
            }
          }
        }

        // Start typewriter effect after a delay
        setTimeout(typeWriter, 1500);
      }
    });
  });
</script>
